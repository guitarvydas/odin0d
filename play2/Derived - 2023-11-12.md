```
package play
import "core:fmt"

Vector3 :: distinct [3]f32
Quaternion :: distinct quaternion128

// NOTE(bill): For the above basic examples, you may not have any
// particular use for it. However, my main use for them is not for these
// simple cases. My main use is for hierarchical types. Many prefer
// subtyping, embedding the base data into the derived types. Below is
// an example of this for a basic game Entity.

Entity :: struct {
    id:          u64,
    name:        string,
    position:    Vector3,
    orientation: Quaternion,
    
    derived: any,
}

Frog :: struct {
    using entity: Entity,
    jump_height:  f32,
}

Monster :: struct {
    using entity: Entity,
    is_robot:     bool,
    is_zombie:    bool,
}

main :: proc () {
    // More realistic examples
    {
        // See `parametric_polymorphism` procedure for details
        new_entity :: proc($T: typeid) -> ^Entity {
            t := new(T)
            t.derived = t^
                return t
        }
        
        entity := new_entity(Monster)
        
        switch e in entity.derived {
        case Frog:
            fmt.println("Ribbit")
        case Monster:
            entity.is_zombie = true
            if e.is_robot  { fmt.println("Robotic") }
            if e.is_zombie { fmt.println("Grrrr!")  }
            fmt.println("I'm a monster")
        }
    }
}
```
## Sketch

